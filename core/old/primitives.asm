; **********************************************************************************************************
;
;		Name:		primitives.asm
;		Purpose		Primitive Words for Z80 CMForth Core (5.1.1)
;		Author:		Paul Robson (paul@robsons.org.uk)
;		Date:		28th January 2018
;
; **********************************************************************************************************

; **********************************************************************************************************
;										swap : swap top two values
; **********************************************************************************************************

WD_Swap:exx												; ==== swap ====
		pop 	hl
		pop 	de
		push 	hl
		push 	de
		exx
		jp 		(ix)

; **********************************************************************************************************
;										   over : copy 2nd to top
; **********************************************************************************************************

WD_Over:exx 											; ==== over ====
		pop 	hl
		pop 	de
		push 	de
		push 	hl
		push 	de
		exx
		jp 		(ix)
		db 		0,0,0

; **********************************************************************************************************
;										dup : Duplicate TOS
; **********************************************************************************************************

WD_Dup: 												; ==== dup ==== 
		pop 	hl
		push 	hl
		push 	hl
		jp 		(ix)
		db 		0,0,0

; **********************************************************************************************************
;										  drop : Drop TOS
; **********************************************************************************************************

WD_Drop: 												; ==== drop ====
		pop 	hl
		jp 		(ix)
		db 		0		

; **********************************************************************************************************
;											xor : exclusive or
; **********************************************************************************************************

WD_Xor:													; ==== xor ====
		exx
		pop 	hl
		pop 	de
		ld 		a,h
		xor 	d
		ld 		h,a
		ld 		a,l
		xor 	e
		jr 		__LogExit
		db 		0,0

; **********************************************************************************************************
;											and : bitwise and
; **********************************************************************************************************

WD_And:													; ==== and ====
		exx
		pop 	hl
		pop 	de
		ld 		a,h
		and 	d
		ld 		h,a
		ld 		a,l
		and 	e
__LogExit:
		ld 		l,a
		push 	hl
		exx
		jp 		(ix)
		db 		0,0,0

; **********************************************************************************************************
;											or : bitwise or
; **********************************************************************************************************

WD_Or:													; ==== or ====
		exx
		pop 	hl
		pop 	de
		ld 		a,h
		or 		d
		ld 		h,a
		ld 		a,l
		or 		e
		jr 		__LogExit
		db 		0,0

; **********************************************************************************************************
;											- : subtract
; **********************************************************************************************************

WD_Subtract:											; ==== - ====
		exx
		xor 	a
		pop 	de
		pop 	hl
		sbc 	hl,de
		push 	hl
		exx
		jp 		(ix)
		db 		0,0

; **********************************************************************************************************
;												0< : test negative
; **********************************************************************************************************

WD_ZLess:												; ==== 0< ====
		pop 	hl
		bit 	7,h
		ld 		hl,0
		jr 		z,__ZE1
		dec 	hl
__ZE1:	push 	hl
		jp 		(ix)


; **********************************************************************************************************
;									negate : twos complement
; **********************************************************************************************************

WD_Negate:												; ==== negate ====
		exx
		xor 	a
		ld 		l,a
		ld 		h,a
		pop 	de
		sbc 	hl,de
		push 	hl
		exx
		jp 		(ix)
		db 		0

; **********************************************************************************************************
;									   			@ : 16 bit read
; **********************************************************************************************************

WD_Read16: 												; ==== @ ====
		pop 	hl
		ld 		a,(hl)
		inc 	hl
		ld 		h,(hl)
		ld 		l,a
		push 	hl
		jp 		(ix)

; **********************************************************************************************************
;									   			! : 16 bit write
; **********************************************************************************************************

WD_Write16: 											; ==== ! ====
		exx
		pop 	hl
		pop 	de
		ld 		(hl),e
		inc 	hl
		ld 		(hl),d
		exx
		jp 		(ix)
		db 		0,0,0

; **********************************************************************************************************
;										rot : rotate top 3
; **********************************************************************************************************

WD_Rot:	exx 											; ==== rot ====
		pop 	hl
		pop 	de
		pop 	bc
		push 	de
		push 	hl
		push 	bc
		exx
		jp 		(ix)
		db 		0,0

; **********************************************************************************************************
;								0= : test equal zero / logical not
; **********************************************************************************************************

WD_ZEquals:												; ==== 0= ====
WD_Not:													; ==== not ====
		pop 	hl
		ld 		a,h
		or 		l
		ld 		hl,0
		jr 		nz,__ZE0
		dec 	hl
__ZE0:	push 	hl
		jp 		(ix)

; **********************************************************************************************************
;											< : less than
; **********************************************************************************************************

WD_LessThan:											; ==== < ====
		exx
		pop 	de
		pop 	hl
__WDCheck:
		xor 	a
		sbc 	hl,de
		ld	 	de,0 									; return 0
		bit 	7,h
		jr 		z,__WDLTPos
__WDLTTrue:		
		dec 	de 										; if h.7 set return 1.
__WDLTPos:
		push 	de
		exx
		jp 		(ix)
		db 		0,0

; **********************************************************************************************************
;										   > : greater than
; **********************************************************************************************************

WD_GreaterThan:											; ==== > ====
		exx 
		pop 	hl
		pop 	de
		jr 		__WDCheck
		db 		0,0,0

; **********************************************************************************************************
;										   = : equals
; **********************************************************************************************************

WD_Equals:												; ==== = ====
		exx 	
		pop 	de
		pop 	hl
		xor 	a
		sbc 	hl,de
		ld 		de,0
		ld 		a,h
		or 		l
		jr 		nz,__WDLTPos
		jr 		__WDLTTrue
		db 		0

; **********************************************************************************************************
;										   u< : unsigned less than.
; **********************************************************************************************************

WD_ULessThan:											; ==== u< ====
		exx 	
		pop 	de
		pop 	hl
		xor 	a
		sbc 	hl,de
		ld 		e,a
		ld 		d,a
		jr 		c,__WDLTTrue
		jr 		__WDLTPos

; **********************************************************************************************************
;								?dup : duplicate top if it is non zero
; **********************************************************************************************************

WD_QDup:												; ==== ?dup ====
		pop 	hl
		push 	hl
		ld 		a,h
		or 		l
		jp 		nz,WD_Dup
		jp 		(ix)
		db 		0,0,0
